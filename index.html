<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, user-scalable=yes, viewport-fit=cover" />
<title>Taíno Conuco Layout • v6 (research defaults + resizable shapes)</title>
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  :root{--gap:10px;--radius:10px}
  body{font-family:-apple-system,system-ui,Segoe UI,Roboto,Arial,sans-serif;background:#f5f1e8;color:#222;line-height:1.3;padding:var(--gap)}
  .container{width:min(100%,960px);margin-inline:auto;background:#fff;border:2px solid #333;padding:var(--gap);border-radius:var(--radius)}
  h1{font-size:clamp(14px,3.8vw,20px);text-align:center;margin-bottom:6px}
  .badge{text-align:center;font-size:11px;color:#666;margin-bottom:8px}
  .controls{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:10px}
  @media (min-width:600px){.controls{grid-template-columns:repeat(5,1fr)}}
  button{padding:12px;background:#4a4a4a;color:#fff;border:0;border-radius:8px;font-size:clamp(11px,3.2vw,14px);cursor:pointer;touch-action:manipulation}
  button:active{background:#666}
  .coords{display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:8px;margin-bottom:10px;font-size:clamp(10px,2.8vw,12px)}
  .coord-item{background:#f9f9f9;padding:8px;border-left:3px solid #666;border-radius:6px}
  .coord-item strong{display:block;margin-bottom:4px}
  .coord-item input{width:64px;padding:6px 5px;font-size:clamp(11px,3vw,13px);margin:0 4px;border:1px solid #ccc;border-radius:6px;-webkit-text-size-adjust:100%}
  .measurements{background:#fffde7;padding:8px;margin-bottom:10px;font-size:clamp(10px,2.8vw,12px);border-left:3px solid #daa520;border-radius:6px;min-height:20px}
  .measurements div{margin:2px 0}
  .live{color:#06c;font-weight:700}
  #canvasWrapper{width:100%;height:min(62dvh,560px);min-height:280px;border:2px solid #333;background:#fff;overflow:hidden;position:relative;border-radius:var(--radius)}
  canvas{display:block;width:100%;height:100%;touch-action:none;cursor:crosshair}
  /* selection + handles */
  .legend{font-size:12px;margin-bottom:6px;color:#444}
</style>
</head>
<body>
  <div class="container">
    <h1>Taíno Conuco Layout Tool</h1>
    <div class="badge">build v6 • research defaults (9 ft mound, 2 cassava) • crisp text • resizable shapes</div>

    <div class="controls">
      <button id="applyBtn">Apply</button>
      <button id="resetDefaultBtn">Reset</button>
      <button id="resetZeroBtn">Center</button>
      <button id="toggleGridBtn">Grid</button>
      <button id="fitBtn">Fit</button>
    </div>

    <div class="legend">Drag shapes to move. Drag handles to resize (rect: 8 handles, circle: radius handle).</div>

    <div class="coords" id="coordInputs"></div>
    <div class="measurements" id="measurements">Loading…</div>

    <div id="canvasWrapper">
      <canvas id="canvas"></canvas>
      <!-- mini-map kept for orientation -->
      <canvas id="miniMap" style="position:absolute;right:8px;bottom:8px;width:140px;height:100px;border:1px solid #333;background:#ffffffcc;border-radius:6px"></canvas>
    </div>
  </div>

<script>
/* ========= Constants & State ========= */
if(!Math.hypot){Math.hypot=(x,y)=>Math.sqrt(x*x+y*y);}
const SCALE = 10;                    // px per foot for measurements
const MONTON_DIAM_FT = 9;            // research default (≈ 9 ft diameter mound)   [oai_citation:1‡Conuco Research 9.30.25.pdf](file-service://file-2HQY6NDLs7WBAMiRsru62u)
const MONTON_RADIUS_PX = (MONTON_DIAM_FT * SCALE)/2; // 45 px at SCALE=10

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d',{alpha:true});
const mini = document.getElementById('miniMap');
const mctx = mini.getContext('2d');
const wrapper = document.getElementById('canvasWrapper');

let CENTER_X = 350, CENTER_Y = 400;
let showGrid = true;
let viewScale = 1, panX = 0, panY = 0;
const MIN_SCALE = 0.5, MAX_SCALE = 4;

let elements = [];
let dragging = null, dragOffX = 0, dragOffY = 0;
let activeHandle = null; // {type:'rect'|'circle', corner:'nw'...'se'|'radius', el:ref, start:{...}}
let panning = false, panStartX = 0, panStartY = 0;
let pinching = false, pinchStartDist = 0, pinchStartScale = 1, pinchFocalX = 0, pinchFocalY = 0;
let inertiaVX=0, inertiaVY=0, inertiaId=0, lastMoveTime=0, lastMoveX=0, lastMoveY=0, lastTap=0;

/* ========= Defaults (research-aligned) ========= */
const defaultCoords = {
  barn:    {x: -270, y:  60, w: 18*12/12*10, h: 160}, // keep existing visual scale, user can resize
  house:   {x:  100, y:  60, w: 160, h: 160},
  planter: {x: -170, y:-240, w:  80, h:  50},
  conuco:  {x:   10, y:-170, r: MONTON_RADIUS_PX},     // 9 ft diameter mound
  septic:  {x: -150, y: 280, r: 35},
  palm:    {x:  130, y: 250, r: 15}
};
// Above: the conuco mound is ~9 ft diameter with **2 cassava** plants per mound.   [oai_citation:2‡Conuco Research 9.30.25.pdf](file-service://file-2HQY6NDLs7WBAMiRsru62u)

/* ========= UI wiring ========= */
document.getElementById('applyBtn').onclick = ()=>{createElementsFromInputs(); draw();};
document.getElementById('resetDefaultBtn').onclick = ()=>{resetToDefault();};
document.getElementById('resetZeroBtn').onclick = ()=>{resetViewAndCoords();};
document.getElementById('toggleGridBtn').onclick = ()=>{showGrid=!showGrid; draw();};
document.getElementById('fitBtn').onclick = ()=>{fitToExtents();};

/* ========= Inputs ========= */
function createCoordInputs(){
  const fields = [
    ['barn','Rect'],['house','Rect'],['planter','Rect'],
    ['conuco','Mound'],['septic','Circle'],['palm','Palm']
  ];
  const html = fields.map(([id,label])=>{
    const d = defaultCoords[id];
    const extra = (id==='conuco'||id==='septic'||id==='palm')
      ? `R:<input type="number" id="${id}R" value="${Math.round(d.r || 30)}">`
      : `W:<input type="number" id="${id}W" value="${d.w||100}"> H:<input type="number" id="${id}H" value="${d.h||100}">`;
    return `<div class="coord-item">
      <strong>${label}</strong>
      X:<input type="number" id="${id}X" value="${d.x}">
      Y:<input type="number" id="${id}Y" value="${d.y}">
      ${extra}
    </div>`;
  }).join('');
  document.getElementById('coordInputs').innerHTML = html;
}
function resetToDefault(){
  createCoordInputs();
  createElementsFromInputs();
  draw();
}
function resetViewAndCoords(){
  panX=panY=0; viewScale=1;
  Object.keys(defaultCoords).forEach(id=>{
    const d=defaultCoords[id];
    document.getElementById(id+'X').value=d.x;
    document.getElementById(id+'Y').value=d.y;
    if (document.getElementById(id+'W')) document.getElementById(id+'W').value=d.w||100;
    if (document.getElementById(id+'H')) document.getElementById(id+'H').value=d.h||100;
    if (document.getElementById(id+'R')) document.getElementById(id+'R').value=Math.round(d.r||30);
  });
  createElementsFromInputs();
  draw();
}

/* ========= Elements from inputs ========= */
function createElementsFromInputs(){
  const getV = (id,s) => parseInt(document.getElementById(id+s).value,10)||0;
  elements = [
    { id:'barn', type:'rect', x: getV('barn','X')+CENTER_X, y:getV('barn','Y')+CENTER_Y,
      width: Math.max(40, getV('barn','W')), height: Math.max(40, getV('barn','H')),
      color:'#d4c5a0', label:'BARN', draggable:true, resizable:true },
    { id:'house', type:'rect', x: getV('house','X')+CENTER_X, y:getV('house','Y')+CENTER_Y,
      width: Math.max(40, getV('house','W')), height: Math.max(40, getV('house','H')),
      color:'#e8dcc8', label:'House', draggable:true, resizable:true },
    { id:'planter', type:'rect', x: getV('planter','X')+CENTER_X, y:getV('planter','Y')+CENTER_Y,
      width: Math.max(30, getV('planter','W')), height: Math.max(24, getV('planter','H')),
      color:'#c07860', label:'Planter', draggable:true, resizable:true },
    { id:'conuco', type:'circle', x: getV('conuco','X')+CENTER_X, y:getV('conuco','Y')+CENTER_Y,
      radius: Math.max(24, getV('conuco','R')), color:'#8b7355', label:'CONUCO', draggable:true, resizable:true },
    { id:'septic', type:'circle', x: getV('septic','X')+CENTER_X, y:getV('septic','Y')+CENTER_Y,
      radius: Math.max(16, getV('septic','R')), color:'#e0e0e0', label:'SEPTIC', draggable:true, resizable:true, dash:true },
    { id:'palm', type:'special', x: getV('palm','X')+CENTER_X, y:getV('palm','Y')+CENTER_Y,
      radius: Math.max(10, getV('palm','R')), color:'#8b7355', label:'Palm', draggable:true, resizable:false }
  ];

  // Place **two** cassava plants on mound slopes (research)    [oai_citation:3‡Conuco Research 9.30.25.pdf](file-service://file-2HQY6NDLs7WBAMiRsru62u)
  const c = elements.find(e=>e.id==='conuco');
  const ring = c.radius - 12;
  const angleA = -Math.PI/6, angleB = Math.PI*5/6; // opposite-ish sides
  const cass = [
    {x:c.x + ring*Math.cos(angleA), y:c.y + ring*Math.sin(angleA)},
    {x:c.x + ring*Math.cos(angleB), y:c.y + ring*Math.sin(angleB)}
  ];
  cass.forEach((p,i)=>elements.push({
    id:'cassava'+(i+1), type:'circle', x:p.x, y:p.y, radius:6, color:'#228b22', label:'', draggable:true, resizable:false
  }));

  updateMeasurements();
}

/* ========= Measurements ========= */
function updateMeasurements(){
  const get = id => elements.find(e=>e.id===id);
  const dist = (e1,e2)=>Math.hypot(e1.x-e2.x,e1.y-e2.y)/SCALE;
  const barn=get('barn'), house=get('house'), planter=get('planter'), conuco=get('conuco'), septic=get('septic'), palm=get('palm');
  document.getElementById('measurements').innerHTML = `
    <div>Barn → Planter: <span class="live">${dist(barn,planter).toFixed(1)}</span> ft</div>
    <div>Barn → Septic: <span class="live">${dist(barn,septic).toFixed(1)}</span> ft</div>
    <div>Barn → House: <span class="live">${(Math.abs(house.x-(barn.x+barn.width))/SCALE).toFixed(1)}</span> ft</div>
    <div>House → Palm: <span class="live">${dist(house,palm).toFixed(1)}</span> ft</div>
    <div>Palm → Septic: <span class="live">${dist(palm,septic).toFixed(1)}</span> ft</div>
    <div>Conuco → Septic (edge): <span class="live">${((dist(conuco,septic)*SCALE - conuco.radius - septic.radius)/SCALE).toFixed(1)}</span> ft</div>
    <div>Conuco diameter: <span class="live">${(conuco.radius*2/SCALE).toFixed(1)}</span> ft (target ≈ ${MONTON_DIAM_FT})</div>
  `;
}

/* ========= Drawing (crisp text via correct transforms) ========= */
function resizeCanvas(){
  const rect = wrapper.getBoundingClientRect();
  const dpr = Math.max(1, window.devicePixelRatio||1);
  canvas.width = Math.floor(rect.width * dpr);
  canvas.height= Math.floor(rect.height* dpr);
  CENTER_X = rect.width/2; CENTER_Y = rect.height/2;

  const mr = mini.getBoundingClientRect();
  mini.width = Math.floor(mr.width * dpr);
  mini.height= Math.floor(mr.height* dpr);

  draw();
}
function setupResizeWatcher(){
  if (window.ResizeObserver){ new ResizeObserver(resizeCanvas).observe(wrapper); }
  else { addEventListener('resize',resizeCanvas); addEventListener('orientationchange',resizeCanvas); }
}

function draw(){
  const dpr=Math.max(1,window.devicePixelRatio||1);

  // Clear at pixel resolution
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Apply DPR then view
  ctx.setTransform(dpr*viewScale,0,0,dpr*viewScale,dpr*panX,dpr*panY);
  const w=canvas.width/dpr, h=canvas.height/dpr;

  // Titles (font size scaled to viewScale for crispness)
  ctx.fillStyle='#333'; ctx.textAlign='center'; ctx.textBaseline='alphabetic';
  ctx.font = `bold ${11/viewScale}px Arial`;
  ctx.fillText('NORTH',CENTER_X,20);
  ctx.fillText('SOUTH',CENTER_X,h-20);

  if (showGrid){
    ctx.strokeStyle='#ddd'; ctx.lineWidth=1/viewScale;
    for(let x=0;x<=w;x+=100){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,h);ctx.stroke();}
    for(let y=0;y<=h;y+=100){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(w,y);ctx.stroke();}
    ctx.strokeStyle='#999'; ctx.lineWidth=2/viewScale;
    ctx.beginPath(); ctx.moveTo(CENTER_X,0); ctx.lineTo(CENTER_X,h); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,CENTER_Y); ctx.lineTo(w,CENTER_Y); ctx.stroke();
  }

  // Draw elements
  elements.forEach(el=>drawElement(el));

  // Draw selection handles if any
  if (dragging && dragging.resizable){ drawHandles(dragging); }
  else if (activeHandle && activeHandle.el){ drawHandles(activeHandle.el); }

  drawMiniMap();
}
function drawElement(el){
  if (el.type==='rect'){
    ctx.fillStyle=el.color; ctx.strokeStyle='#333'; ctx.lineWidth=2/viewScale;
    ctx.fillRect(el.x,el.y,el.width,el.height); ctx.strokeRect(el.x,el.y,el.width,el.height);
    if (el.label){ ctx.fillStyle='#000'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.font = `bold ${11/viewScale}px Arial`;
      ctx.fillText(el.label, el.x+el.width/2, el.y+el.height/2);
    }
  } else if (el.type==='circle'){
    ctx.fillStyle=el.color; ctx.strokeStyle='#333'; ctx.lineWidth=(el.radius>10?2:1)/viewScale;
    if (el.dash) ctx.setLineDash([5/viewScale,5/viewScale]);
    ctx.beginPath(); ctx.arc(el.x,el.y,el.radius,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.setLineDash([]);
    if (el.label){ ctx.fillStyle='#000'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.font = `${(el.radius>30?9:8)/viewScale}px Arial`;
      ctx.fillText(el.label, el.x, el.y);
    }
  } else if (el.type==='special'){ // palm glyph
    ctx.fillStyle=el.color; ctx.strokeStyle='#333'; ctx.lineWidth=2/viewScale;
    ctx.beginPath(); ctx.ellipse(el.x,el.y,12,20,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.strokeStyle='#2d5016';
    for(let i=0;i<5;i++){
      ctx.beginPath(); ctx.moveTo(el.x,el.y-15);
      const ang=(i-2)*0.4;
      ctx.quadraticCurveTo(el.x+Math.sin(ang)*15, el.y-30, el.x+Math.sin(ang)*20, el.y-40);
      ctx.stroke();
    }
  }
}

/* ========= Selection & Handles ========= */
function getHandleHit(el, x, y){
  const S = 7; // handle size in CSS px (screen space)
  // convert screen->world for stable math already done by caller
  if (el.type==='rect'){
    const pts = [
      ['nw', el.x, el.y], ['n', el.x+el.width/2, el.y], ['ne', el.x+el.width, el.y],
      ['w', el.x, el.y+el.height/2], ['e', el.x+el.width, el.y+el.height/2],
      ['sw', el.x, el.y+el.height], ['s', el.x+el.width/2, el.y+el.height], ['se', el.x+el.width, el.y+el.height]
    ];
    for (const [name,hx,hy] of pts){
      const dx = Math.abs(x - hx), dy = Math.abs(y - hy);
      if (dx <= S/viewScale && dy <= S/viewScale) return {type:'rect', corner:name};
    }
  } else if (el.type==='circle'){
    // radius handle at eastmost point
    const hx = el.x + el.radius, hy = el.y;
    if (Math.abs(x - hx) <= 7/viewScale && Math.abs(y - hy) <= 7/viewScale)
      return {type:'circle', corner:'radius'};
  }
  return null;
}
function drawHandles(el){
  ctx.save();
  ctx.setLineDash([]);
  ctx.lineWidth = 1.5/viewScale;
  ctx.strokeStyle = '#0a84ff';
  ctx.fillStyle = '#fff';
  if (el.type==='rect'){
    ctx.strokeRect(el.x, el.y, el.width, el.height);
    const pts = [
      [el.x,el.y],[el.x+el.width/2,el.y],[el.x+el.width,el.y],
      [el.x,el.y+el.height/2],[el.x+el.width,el.y+el.height/2],
      [el.x,el.y+el.height],[el.x+el.width/2,el.y+el.height],[el.x+el.width,el.y+el.height]
    ];
    pts.forEach(([px,py])=>{
      ctx.beginPath(); ctx.rect(px-4/viewScale, py-4/viewScale, 8/viewScale, 8/viewScale);
      ctx.fill(); ctx.stroke();
    });
  } else if (el.type==='circle'){
    ctx.beginPath(); ctx.arc(el.x,el.y,el.radius,0,Math.PI*2); ctx.stroke();
    // radius handle
    const hx = el.x + el.radius, hy = el.y;
    ctx.beginPath(); ctx.rect(hx-4/viewScale, hy-4/viewScale, 8/viewScale, 8/viewScale);
    ctx.fill(); ctx.stroke();
  }
  ctx.restore();
}

/* ========= Hit testing ========= */
function screenToWorld(px,py){ return {x:(px - panX)/viewScale, y:(py - panY)/viewScale}; }
function elementAt(x,y){
  for (let i=elements.length-1;i>=0;i--){
    const e=elements[i]; if(!e.draggable) continue;
    if (e.type==='rect' && x>=e.x && x<=e.x+e.width && y>=e.y && y<=e.y+e.height) return e;
    if ((e.type==='circle'||e.type==='special') && Math.hypot(x-e.x,y-e.y)<= (e.radius||15)) return e;
  }
  return null;
}

/* ========= Input ========= */
canvas.addEventListener('wheel', e=>{
  e.preventDefault();
  const rect=canvas.getBoundingClientRect();
  const p={x:e.clientX-rect.left,y:e.clientY-rect.top};
  zoomAt(p.x,p.y, e.deltaY<0?1.1:1/1.1);
},{passive:false});

canvas.addEventListener('mousedown', e=>{
  const rect=canvas.getBoundingClientRect(), p={x:e.clientX-rect.left,y:e.clientY-rect.top};
  const w=screenToWorld(p.x,p.y);
  const el = elementAt(w.x,w.y);
  if (el && el.resizable){
    const h = getHandleHit(el, w.x, w.y);
    if (h){ activeHandle = {el, ...h, start:{x:w.x,y:w.y, ex:el.x, ey:el.y, ew:el.width, eh:el.height, er:el.radius}}; return; }
  }
  if (el){ dragging=el; dragOffX=w.x-el.x; dragOffY=w.y-el.y; }
  else { panning=true; panStartX=p.x-panX; panStartY=p.y-panY; inertiaVX=inertiaVY=0; lastMoveTime=Date.now(); lastMoveX=p.x; lastMoveY=p.y; }
  const now=Date.now(); if (now-lastTap<300) zoomAt(p.x,p.y,1.6); lastTap=now;
});
window.addEventListener('mousemove', e=>{
  const rect=canvas.getBoundingClientRect(), p={x:e.clientX-rect.left,y:e.clientY-rect.top};
  const w=screenToWorld(p.x,p.y);
  if (activeHandle){
    const H=activeHandle;
    if (H.type==='rect'){
      let nx=H.el.x, ny=H.el.y, nw=H.el.width, nh=H.el.height;
      const min=24;
      const dx=w.x-H.start.x, dy=w.y-H.start.y;
      if (H.corner.includes('n')){ ny = H.start.ey + dy; nh = H.start.eh - dy; }
      if (H.corner.includes('s')){ nh = H.start.eh + dy; }
      if (H.corner.includes('w')){ nx = H.start.ex + dx; nw = H.start.ew - dx; }
      if (H.corner.includes('e')){ nw = H.start.ew + dx; }
      if (nw<min){ nx += (nw-min); nw=min; }
      if (nh<min){ ny += (nh-min); nh=min; }
      H.el.x=nx; H.el.y=ny; H.el.width=nw; H.el.height=nh;
      updateInputs(); updateMeasurements(); draw();
    } else if (H.type==='circle' && H.corner==='radius'){
      const r = Math.max(10, Math.hypot(w.x - H.el.x, w.y - H.el.y));
      H.el.radius = r; if (H.el.id==='conuco') updateInputs(); updateMeasurements(); draw();
    }
    return;
  }
  if (dragging){
    dragging.x=w.x - dragOffX; dragging.y=w.y - dragOffY; updateInputs(); updateMeasurements(); draw(); return;
  }
  if (panning){
    const now=Date.now(); inertiaVX=(p.x-lastMoveX)/Math.max(1,now-lastMoveTime); inertiaVY=(p.y-lastMoveY)/Math.max(1,now-lastMoveTime);
    lastMoveTime=now; lastMoveX=p.x; lastMoveY=p.y;
    panX=p.x-panStartX; panY=p.y-panStartY; draw();
  }
});
window.addEventListener('mouseup', ()=>{
  if(panning) startInertia();
  dragging=null; panning=false; activeHandle=null;
});

/* touch */
canvas.addEventListener('touchstart', e=>{
  if (e.touches.length===1){
    const t=e.touches[0], r=canvas.getBoundingClientRect(), p={x:t.clientX-r.left,y:t.clientY-r.top}, w=screenToWorld(p.x,p.y);
    const el = elementAt(w.x,w.y);
    if (el && el.resizable){
      const h = getHandleHit(el, w.x, w.y);
      if (h){ activeHandle={el,...h,start:{x:w.x,y:w.y,ex:el.x,ey:el.y,ew:el.width,eh:el.height,er:el.radius}}; e.preventDefault(); return; }
    }
    if (el){ dragging=el; dragOffX=w.x-el.x; dragOffY=w.y-el.y; }
    else { panning=true; panStartX=p.x-panX; panStartY=p.y-panY; inertiaVX=inertiaVY=0; lastMoveTime=Date.now(); lastMoveX=p.x; lastMoveY=p.y; }
    const now=Date.now(); if (now-lastTap<350){ zoomAt(p.x,p.y,1.6); e.preventDefault(); } lastTap=now;
  } else if (e.touches.length===2){
    pinching=true; dragging=null; panning=false;
    const a=e.touches[0], b=e.touches[1];
    pinchStartDist=Math.hypot(b.clientX-a.clientX,b.clientY-a.clientY); pinchStartScale=viewScale;
    const cx=(a.clientX+b.clientX)/2, cy=(a.clientY+b.clientY)/2, r=canvas.getBoundingClientRect();
    pinchFocalX=cx-r.left; pinchFocalY=cy-r.top;
  }
},{passive:false});
canvas.addEventListener('touchmove', e=>{
  if (pinching && e.touches.length===2){
    e.preventDefault();
    const a=e.touches[0], b=e.touches[1];
    const dist=Math.hypot(b.clientX-a.clientX,b.clientY-a.clientY);
    const factor=dist/pinchStartDist;
    setZoomAt(pinchFocalX,pinchFocalY, pinchStartScale*factor);
  } else if (e.touches.length===1){
    const t=e.touches[0], r=canvas.getBoundingClientRect(), p={x:t.clientX-r.left,y:t.clientY-r.top}, w=screenToWorld(p.x,p.y);
    if (activeHandle){
      const H=activeHandle;
      if (H.type==='rect'){
        let nx=H.el.x, ny=H.el.y, nw=H.el.width, nh=H.el.height;
        const min=24, dx=w.x-H.start.x, dy=w.y-H.start.y;
        if (H.corner.includes('n')){ ny = H.start.ey + dy; nh = H.start.eh - dy; }
        if (H.corner.includes('s')){ nh = H.start.eh + dy; }
        if (H.corner.includes('w')){ nx = H.start.ex + dx; nw = H.start.ew - dx; }
        if (H.corner.includes('e')){ nw = H.start.ew + dx; }
        if (nw<min){ nx += (nw-min); nw=min; }
        if (nh<min){ ny += (nh-min); nh=min; }
        H.el.x=nx; H.el.y=ny; H.el.width=nw; H.el.height=nh;
        updateInputs(); updateMeasurements(); draw();
      } else if (H.type==='circle'){
        H.el.radius = Math.max(10, Math.hypot(w.x-H.el.x, w.y-H.el.y));
        if (H.el.id==='conuco') updateInputs(); updateMeasurements(); draw();
      }
      e.preventDefault(); return;
    }
    if (dragging){
      dragging.x=w.x - dragOffX; dragging.y=w.y - dragOffY; updateInputs(); updateMeasurements(); draw(); e.preventDefault(); return;
    }
    if (panning){
      const now=Date.now(); inertiaVX=(p.x-lastMoveX)/Math.max(1,now-lastMoveTime); inertiaVY=(p.y-lastMoveY)/Math.max(1,now-lastMoveTime);
      lastMoveTime=now; lastMoveX=p.x; lastMoveY=p.y;
      panX=p.x - panStartX; panY=p.y - panStartY; draw(); e.preventDefault();
    }
  }
},{passive:false});
canvas.addEventListener('touchend', ()=>{
  if(panning && !pinching) startInertia();
  pinching=false; dragging=null; panning=false; activeHandle=null;
});

/* ========= Zoom & Inertia ========= */
function clamp(v,lo,hi){ return
